<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Audio Call App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px;
      -webkit-text-size-adjust: 100%;
    }

    .video-container {
      display: none;
      /* Hidden by default for audio call appearance */
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .video-wrapper {
      flex: 1;
      min-width: 280px;
    }

    .video-wrapper h3 {
      margin-top: 0;
      text-align: center;
      background: #f0f0f0;
      padding: 10px;
      border-radius: 5px 5px 0 0;
      margin-bottom: 0;
      font-size: 16px;
    }

    video {
      width: 100%;
      height: 250px;
      background: black;
      border: 2px solid #ccc;
      border-radius: 0 0 5px 5px;
      object-fit: cover;
      -webkit-playsinline: true;
    }

    input,
    button {
      margin: 5px;
      padding: 10px;
      font-size: 16px;
      /* Prevent zoom on iOS */
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      background: linear-gradient(to bottom, #f9f9f9, #e9e9e9);
    }

    /* Mobile-specific styles */
    @media (max-width: 768px) {
      body {
        padding: 5px;
      }

      .video-container {
        flex-direction: column;
        gap: 10px;
      }

      .video-wrapper {
        min-width: 100%;
      }

      video {
        height: 200px;
        /* Android-specific optimizations */
        transform: translateZ(0);
        /* Force hardware acceleration */
        -webkit-transform: translateZ(0);
      }

      input,
      button {
        width: 100%;
        box-sizing: border-box;
        margin: 5px 0;
        min-height: 44px;
        /* Better touch targets for Android */
      }

      h2 {
        font-size: 20px;
        text-align: center;
      }
    }

    /* Android-specific optimizations */
    @media screen and (-webkit-min-device-pixel-ratio: 1) {
      video {
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        will-change: transform;
        /* Optimize for animations */
      }
    }
  </style>
</head>

<body>
  <h2>Audio Call App</h2>

  <div id="mobileWarning"
    style="display: none; margin: 10px 0; padding: 15px; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 5px;">
    <h4 style="margin-top: 0; color: #1976d2;">📱 Mobile Device Detected</h4>
    <p style="color: #1976d2; margin-bottom: 0;">For best results on Android/Mobile:</p>
    <ul style="color: #1976d2; margin-bottom: 0;">
      <li><strong>MUST use HTTPS:</strong> Deploy to GitHub Pages (https://yourname.github.io/...)</li>
      <li><strong>Allow permissions:</strong> Camera AND microphone when prompted</li>
      <li><strong>Use Chrome browser</strong> for best compatibility</li>
      <li><strong>Close other camera apps</strong> before using this</li>
      <li>If video is black, refresh the page and try again</li>
      <li>Keep your device charged (camera uses battery)</li>
    </ul>
  </div>

  <div class="video-container">
    <div class="video-wrapper">
      <h3>Your Camera (Local)</h3>
      <video id="localVideo" autoplay muted playsinline webkit-playsinline controls="false"></video>
    </div>
    <div class="video-wrapper">
      <h3>Remote Camera (Other Person)</h3>
      <video id="remoteVideo" autoplay playsinline webkit-playsinline controls="false"></video>
    </div>
  </div>
  <div style="margin: 20px 0;">
    <button id="createCall"
      style="background: #4CAF50; color: white; padding: 15px 30px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer;">Create
      New Call</button>
  </div>

  <div id="callIdSection"
    style="display: none; margin: 20px 0; padding: 20px; background: #f0f0f0; border-radius: 5px;">
    <h3>Your Call ID:</h3>
    <div style="display: flex; align-items: center; gap: 10px;">
      <input type="text" id="generatedCallId" readonly
        style="font-size: 24px; font-weight: bold; padding: 10px; width: 200px; text-align: center; border: 2px solid #4CAF50; border-radius: 5px;">
      <button id="copyCallId"
        style="background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">Copy
        ID</button>
    </div>
    <p style="color: #666; margin-top: 10px;">Share this ID with the person you want to call</p>
  </div>

  <div style="margin: 20px 0;">
    <h3>Join a Call:</h3>
    <div style="display: flex; align-items: center; gap: 10px;">
      <input type="text" id="callIdInput" placeholder="Enter Call ID"
        style="padding: 10px; font-size: 16px; width: 200px; border: 2px solid #ccc; border-radius: 5px;">
      <button id="joinCall"
        style="background: #FF9800; color: white; padding: 10px 20px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer;">Join
        Call</button>
    </div>
  </div>

  <!-- End Call Button (hidden by default) -->
  <div id="endCallSection" style="display: none; margin: 20px 0; text-align: center;">
    <button id="toggleVideo"
      style="background: #2196F3; color: white; padding: 12px 20px; border: none; border-radius: 25px; font-size: 16px; cursor: pointer; margin-right: 15px; font-weight: bold;">
      📹 Enable Video
    </button>
    <button id="endCall"
      style="background: #f44336; color: white; padding: 15px 30px; border: none; border-radius: 50px; font-size: 18px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 8px rgba(244, 67, 54, 0.3);">
      ⚫ End Call
    </button>
  </div>

  <div id="statusDisplay"
    style="margin: 20px 0; padding: 10px; background: #e8f5e8; border-radius: 5px; display: none;">
    <p id="statusText"></p>
  </div>

  <!-- Call Ended Modal -->
  <div id="callEndedModal"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center;">
    <div
      style="background: white; padding: 30px; border-radius: 10px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
      <h2 style="color: #f44336; margin-top: 0;">📞 Call Ended</h2>
      <p id="callEndedMessage" style="font-size: 18px; margin: 20px 0; color: #333;">The call has ended.</p>
      <button onclick="closeCallEndedModal()"
        style="background: #4CAF50; color: white; padding: 12px 24px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer;">OK</button>
    </div>
  </div>

  <div id="permissionHelp"
    style="margin: 20px 0; padding: 15px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; display: none;">
    <h4 style="margin-top: 0; color: #856404;">📹 Camera & Microphone Permissions Required</h4>
    <p style="color: #856404; margin-bottom: 10px;">To use video calling, you need to allow camera and microphone
      access:</p>
    <ol style="color: #856404; margin-bottom: 10px;">
      <li>When prompted, click <strong>"Allow"</strong> (not "Block" or "Deny")</li>
      <li>If you see a camera icon in your browser's address bar, click it and select "Allow"</li>
      <li>If you accidentally blocked access, refresh the page and try again</li>
    </ol>
    <div style="display: flex; gap: 10px;">
      <button id="requestPermissionsBtn"
        style="background: #ff6b6b; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">📹
        Allow Camera & Microphone</button>
      <button onclick="document.getElementById('permissionHelp').style.display='none'"
        style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Got
        it!</button>
      <button onclick="window.location.reload()"
        style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Refresh
        Page</button>
    </div>
  </div>

  <script type="module">
    // Mobile device detection and warning
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);

    if (isMobile) {
      document.getElementById('mobileWarning').style.display = 'block';
      console.log('Mobile device detected:', { isMobile, isAndroid });
    }

    // Android-specific checks
    if (isAndroid) {
      console.log('Android device detected - applying Android optimizations');

      // Check for HTTPS on Android
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        const httpsWarning = document.createElement('div');
        httpsWarning.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; background: #f44336; color: white; padding: 10px; text-align: center; z-index: 1000;';
        httpsWarning.innerHTML = '⚠️ HTTPS Required on Android! Please use GitHub Pages (https://yourname.github.io/...)';
        document.body.insertBefore(httpsWarning, document.body.firstChild);
      }

      // Android performance optimizations
      document.addEventListener('DOMContentLoaded', () => {
        // Disable text selection for better mobile experience
        document.body.style.webkitUserSelect = 'none';
        document.body.style.webkitTouchCallout = 'none';
      });
    }

    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
    import { getDatabase, ref, set, get, onChildAdded, child } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js";

    // ----- Firebase config -----
    const firebaseConfig = {
      apiKey: "AIzaSyDGJvWk6h7JFtuqdsM4RNGJwiQj_ZUz9R8",
      authDomain: "rtc-project-sih.firebaseapp.com",
      databaseURL: "https://rtc-project-sih-default-rtdb.firebaseio.com/",
      projectId: "rtc-project-sih",
      storageBucket: "rtc-project-sih.appspot.com",
      messagingSenderId: "21024104436",
      appId: "1:21024104436:web:23cf8fe41b750d118ba3a1"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const createBtn = document.getElementById("createCall");
    const joinBtn = document.getElementById("joinCall");
    const callIdInput = document.getElementById("callIdInput");
    const callIdDisplay = document.getElementById("callIdDisplay");
    const callIdSection = document.getElementById("callIdSection");
    const generatedCallId = document.getElementById("generatedCallId");
    const copyCallIdBtn = document.getElementById("copyCallId");
    const statusDisplay = document.getElementById("statusDisplay");
    const statusText = document.getElementById("statusText");
    const endCallBtn = document.getElementById("endCall");
    const endCallSection = document.getElementById("endCallSection");
    const toggleVideoBtn = document.getElementById("toggleVideo");
    const videoContainer = document.querySelector(".video-container");

    let pc;
    let localStream;
    let currentCallId;
    let permissionRequestInProgress = false;
    let videoEnabled = false; // Track video state

    const servers = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "turn:turn.anyfirewall.com:443?transport=tcp", username: "webrtc", credential: "webrtc" }
      ]
    };

    // Manual permission request function for user interaction
    async function requestPermissionsManually() {
      if (permissionRequestInProgress) {
        console.log('Permission request already in progress');
        return;
      }

      try {
        permissionRequestInProgress = true;
        document.getElementById('requestPermissionsBtn').textContent = '⏳ Requesting...';
        document.getElementById('requestPermissionsBtn').disabled = true;

        // Simple request to avoid Android permission loops
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

        // Store the stream globally if successful
        localStream = stream;

        // Store successful permission
        const isAndroid = /Android/i.test(navigator.userAgent);
        if (isAndroid) {
          localStorage.setItem('webrtc_permissions_granted', Date.now().toString());
        }

        console.log('Manual permission request successful');
        document.getElementById('permissionHelp').style.display = 'none';
        showStatus('✅ Camera and microphone access granted! You can now create or join calls.', false);

        return true;
      } catch (error) {
        console.error('Manual permission request failed:', error);

        let errorMsg = 'Permission request failed. ';
        if (error.name === 'NotAllowedError') {
          errorMsg += 'Please click "Allow" when prompted, or check your browser settings.';
        }

        alert(errorMsg);
        document.getElementById('requestPermissionsBtn').textContent = '📹 Allow Camera & Microphone';
        document.getElementById('requestPermissionsBtn').disabled = false;

        return false;
      } finally {
        permissionRequestInProgress = false;
      }
    }

    async function checkPermissions() {
      // Check if Permissions API is available
      if ('permissions' in navigator) {
        try {
          const cameraPermission = await navigator.permissions.query({ name: 'camera' });
          const microphonePermission = await navigator.permissions.query({ name: 'microphone' });

          console.log('Camera permission state:', cameraPermission.state);
          console.log('Microphone permission state:', microphonePermission.state);

          return {
            camera: cameraPermission.state,
            microphone: microphonePermission.state
          };
        } catch (error) {
          console.log('Permissions API not fully supported:', error);
          return null;
        }
      }
      return null;
    }

    async function initMedia() {
      try {
        // Check if we already have a stream from manual permission request
        if (localStream && localStream.getTracks().length > 0) {
          console.log('Using existing stream from manual permission request');

          // Set up local video
          localVideo.srcObject = localStream;
          localVideo.setAttribute('muted', 'true');
          localVideo.setAttribute('playsinline', 'true');
          localVideo.setAttribute('webkit-playsinline', 'true');
          localVideo.setAttribute('autoplay', 'true');

          await localVideo.play().catch(e => console.log('Local video play failed:', e));

          showStatus("Using existing camera and microphone access!");
          return;
        }

        // Check HTTPS requirement for mobile
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
          throw new Error('HTTPS is required for camera/microphone access on mobile devices. Please use GitHub Pages or HTTPS.');
        }

        // Check if getUserMedia is supported
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('Browser does not support camera/microphone access');
        }

        // Check existing permissions first
        const permissionStates = await checkPermissions();
        if (permissionStates) {
          if (permissionStates.camera === 'denied' || permissionStates.microphone === 'denied') {
            throw new Error('Camera or microphone access is permanently denied. Please reset permissions in browser settings.');
          }

          if (permissionStates.camera === 'granted' && permissionStates.microphone === 'granted') {
            console.log('Permissions already granted, proceeding...');
          }
        }

        showStatus("Please allow camera and microphone access when prompted...");

        // Detect device type
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);

        console.log('Device detection:', { isMobile, isAndroid });

        // For Android, use very simple constraints first
        let constraints;
        if (isAndroid) {
          // Simplified constraints for Android to avoid permission loops
          constraints = {
            video: true,
            audio: true
          };
        } else if (isMobile) {
          constraints = {
            video: {
              facingMode: 'user'
            },
            audio: true
          };
        } else {
          // Desktop constraints
          constraints = {
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 }
            },
            audio: true
          };
        }

        // Store successful permission for future reference
        const permissionKey = 'webrtc_permissions_granted';

        // Single request approach to avoid repeated permission prompts on Android
        try {
          console.log('Requesting media with constraints:', constraints);
          localStream = await navigator.mediaDevices.getUserMedia(constraints);

          // Store successful permission
          if (isAndroid) {
            localStorage.setItem(permissionKey, Date.now().toString());
          }

          console.log('Media access successful');
        } catch (mediaError) {
          console.log('Media request failed:', mediaError);

          // Only try basic fallback for Android if the error is constraint-related
          if (isAndroid && (mediaError.name === 'OverconstrainedError' || mediaError.name === 'ConstraintNotSatisfiedError')) {
            console.log('Trying basic Android fallback...');
            try {
              localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
              localStorage.setItem(permissionKey, Date.now().toString());
              console.log('Android fallback successful');
            } catch (fallbackError) {
              console.log('Android fallback failed:', fallbackError);
              throw fallbackError;
            }
          } else {
            throw mediaError;
          }
        }

        // Set up local video with Android-specific handling
        localVideo.srcObject = localStream;

        // Start with video disabled (audio-only mode)
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = false; // Start with video disabled
          videoEnabled = false;
        }

        // Android-specific video attributes
        localVideo.setAttribute('muted', 'true');
        localVideo.setAttribute('playsinline', 'true');
        localVideo.setAttribute('webkit-playsinline', 'true');
        localVideo.setAttribute('autoplay', 'true');

        if (isAndroid) {
          // Additional Android optimizations
          localVideo.setAttribute('preload', 'metadata');
          localVideo.volume = 0; // Ensure muted for autoplay
        }

        // Force video play with multiple attempts
        let playAttempts = 0;
        const maxPlayAttempts = 3;

        const attemptPlay = async () => {
          try {
            await localVideo.play();
            console.log(`Local video play successful on attempt ${playAttempts + 1}`);
            return true;
          } catch (playError) {
            playAttempts++;
            console.log(`Play attempt ${playAttempts} failed:`, playError);

            if (playAttempts < maxPlayAttempts) {
              // Wait and try again
              await new Promise(resolve => setTimeout(resolve, 500));
              return attemptPlay();
            } else {
              console.log('All play attempts failed, but continuing...');
              return false;
            }
          }
        };

        await attemptPlay();

        console.log('Media initialized successfully');
        console.log('Local stream tracks:', localStream.getTracks().map(t => `${t.kind}: ${t.enabled} (${t.readyState})`));
        console.log('Video constraints used:', localStream.getVideoTracks()[0]?.getSettings());
        showStatus("Camera and microphone access granted!");

      } catch (error) {
        console.error('Error accessing media devices:', error);

        let errorMessage = "Error accessing camera/microphone. ";

        if (error.message.includes('HTTPS')) {
          errorMessage = "❌ HTTPS Required: Please use GitHub Pages (https://yourname.github.io/...) to access camera on mobile.";
        } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          errorMessage += "Please click 'Allow' when prompted for camera/microphone permissions. On Android, make sure to allow both camera and microphone.";
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          errorMessage += "No camera or microphone found. Please check your Android device settings.";
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          errorMessage += "Camera/microphone is being used by another app. Please close other camera apps and try again.";
        } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
          errorMessage += "Camera settings not supported. Trying basic camera access...";
        } else {
          errorMessage += "Please ensure permissions are granted and try again.";
        }

        showStatus(errorMessage, true);
        alert(errorMessage);
        throw error;
      }
    }

    function generateCallId() {
      // Generate a more user-friendly 6-character ID
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      let id = "";
      for (let i = 0; i < 6; i++) {
        id += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return id;
    }

    function showStatus(message, isError = false) {
      statusText.textContent = message;
      statusDisplay.style.display = 'block';
      statusDisplay.style.background = isError ? '#ffe8e8' : '#e8f5e8';
      console.log(message);
    }

    function hideStatus() {
      statusDisplay.style.display = 'none';
    }

    // Function to close the call ended modal
    function closeCallEndedModal() {
      document.getElementById('callEndedModal').style.display = 'none';
    }

    // Make closeCallEndedModal globally accessible
    window.closeCallEndedModal = closeCallEndedModal;

    // Function to show call ended modal
    function showCallEndedModal(isInitiator = false) {
      const modal = document.getElementById('callEndedModal');
      const messageElement = document.getElementById('callEndedMessage');

      if (isInitiator) {
        messageElement.textContent = 'You have successfully ended the call.';
      } else {
        messageElement.textContent = 'Call Ended';
      }

      modal.style.display = 'flex';
    }

    // Debug function to check video status
    function checkVideoStatus() {
      console.log('=== VIDEO STATUS CHECK ===');
      console.log('Local video element:', localVideo);
      console.log('Local video srcObject:', localVideo.srcObject);
      console.log('Local video readyState:', localVideo.readyState);
      console.log('Local video paused:', localVideo.paused);
      console.log('Remote video element:', remoteVideo);
      console.log('Remote video srcObject:', remoteVideo.srcObject);
      console.log('Remote video readyState:', remoteVideo.readyState);
      console.log('Remote video paused:', remoteVideo.paused);
      if (localStream) {
        console.log('Local stream tracks:', localStream.getTracks().map(t => `${t.kind}: ${t.enabled}`));
      }
      console.log('========================');
    }

    // Function to end the call
    function endCall() {
      console.log('Ending call...');

      try {
        // Send end call signal to Firebase to notify the other participant
        if (currentCallId) {
          const endCallSignal = {
            type: 'endCall',
            timestamp: Date.now()
          };
          set(ref(db, `calls/${currentCallId}/signals/endCall`), endCallSignal)
            .catch(error => console.error('Error sending end call signal:', error));
        }

        // Stop all local stream tracks
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            console.log('Stopped local track:', track.kind);
          });
          localStream = null;
        }

        // Close peer connection
        if (pc) {
          pc.close();
          console.log('Peer connection closed');
          pc = null;
        }

        // Clear video elements
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;

        // Reset UI state
        endCallSection.style.display = 'none';
        callIdSection.style.display = 'none';

        // Hide video container (keep audio call appearance)
        videoContainer.style.display = 'none';
        videoEnabled = false;
        toggleVideoBtn.textContent = '📹 Enable Video';
        toggleVideoBtn.style.background = '#2196F3';

        // Clear call ID
        callIdInput.value = '';
        generatedCallId.value = '';
        currentCallId = null;

        // Show "Call ended" modal for the person who ended the call as well
        setTimeout(() => {
          showCallEndedModal(true); // true indicates this person initiated the end call
        }, 500);

        console.log('Call ended and UI reset');
      } catch (error) {
        console.error('Error ending call:', error);
        showStatus('Error ending call', true);
      }
    }

    // Function to end call locally without sending signal (used when receiving end call signal)
    function endCallLocally() {
      console.log('Ending call locally (received end signal)...');

      try {
        // Stop all local stream tracks
        if (localStream) {
          localStream.getTracks().forEach(track => {
            track.stop();
            console.log('Stopped local track:', track.kind);
          });
          localStream = null;
        }

        // Close peer connection
        if (pc) {
          pc.close();
          console.log('Peer connection closed');
          pc = null;
        }

        // Clear video elements
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;

        // Reset UI state
        endCallSection.style.display = 'none';
        callIdSection.style.display = 'none';

        // Hide video container (keep audio call appearance)
        videoContainer.style.display = 'none';
        videoEnabled = false;
        toggleVideoBtn.textContent = '📹 Enable Video';
        toggleVideoBtn.style.background = '#2196F3';

        // Clear call ID
        callIdInput.value = '';
        generatedCallId.value = '';
        currentCallId = null;

        console.log('Call ended locally and UI reset');
      } catch (error) {
        console.error('Error ending call locally:', error);
      }
    }

    // Function to toggle video on/off
    function toggleVideo() {
      try {
        if (!localStream) {
          showStatus('No active call to toggle video', true);
          return;
        }

        const videoTrack = localStream.getVideoTracks()[0];
        if (!videoTrack) {
          showStatus('Video track not available', true);
          return;
        }

        videoEnabled = !videoEnabled;

        if (videoEnabled) {
          // Enable video
          videoTrack.enabled = true;
          videoContainer.style.display = 'flex';
          toggleVideoBtn.textContent = '📹 Disable Video';
          toggleVideoBtn.style.background = '#FF9800';
          showStatus('Video enabled');
          console.log('Video enabled');
        } else {
          // Disable video
          videoTrack.enabled = false;
          videoContainer.style.display = 'none';
          toggleVideoBtn.textContent = '📹 Enable Video';
          toggleVideoBtn.style.background = '#2196F3';
          showStatus('Video disabled - Audio only mode');
          console.log('Video disabled');
        }

        // Clear status after a few seconds
        setTimeout(() => {
          hideStatus();
        }, 2000);

      } catch (error) {
        console.error('Error toggling video:', error);
        showStatus('Error toggling video', true);
      }
    }

    async function createPeerConnection(callId, isCaller) {
      try {
        pc = new RTCPeerConnection(servers);
        console.log('PeerConnection created for call:', callId, 'isCaller:', isCaller);

        // Add local tracks to peer connection
        localStream.getTracks().forEach(track => {
          console.log('Adding local track:', track.kind, track.enabled);
          pc.addTrack(track, localStream);
        });

        console.log('Local tracks added to peer connection');

        pc.ontrack = event => {
          console.log('Received remote track:', event.track.kind);
          console.log('Remote streams:', event.streams);

          const isAndroid = /Android/i.test(navigator.userAgent);

          // Handle the remote stream with Android optimizations
          if (event.streams && event.streams[0]) {
            // Use the first stream from the event
            remoteVideo.srcObject = event.streams[0];
            console.log('Remote video stream set successfully from event.streams[0]');

            // Show appropriate status based on track type
            if (event.track.kind === 'video') {
              showStatus('Remote video connected!');
            } else {
              showStatus('Remote audio connected!');
            }
          } else {
            // Fallback: create stream from individual tracks
            console.log('Creating remote stream from track');
            if (!remoteVideo.srcObject) {
              remoteVideo.srcObject = new MediaStream();
            }
            remoteVideo.srcObject.addTrack(event.track);
            console.log('Remote track added to stream');
            showStatus(`Remote ${event.track.kind} track added!`);
          }

          // Android-specific video setup for remote video
          if (isAndroid) {
            remoteVideo.setAttribute('playsinline', 'true');
            remoteVideo.setAttribute('webkit-playsinline', 'true');
            remoteVideo.setAttribute('autoplay', 'true');
            remoteVideo.setAttribute('preload', 'metadata');
          }

          // Ensure remote video plays with multiple attempts for Android
          const attemptRemotePlay = async (attempts = 3) => {
            for (let i = 0; i < attempts; i++) {
              try {
                await remoteVideo.play();
                console.log(`Remote video play successful on attempt ${i + 1}`);
                return;
              } catch (playError) {
                console.log(`Remote play attempt ${i + 1} failed:`, playError);
                if (i < attempts - 1) {
                  await new Promise(resolve => setTimeout(resolve, 300));
                }
              }
            }
            console.log('All remote play attempts failed, but continuing...');
          };

          attemptRemotePlay();
        };

        pc.onconnectionstatechange = () => {
          console.log('Connection state:', pc.connectionState);
          if (pc.connectionState === 'connected') {
            showStatus('Audio call connected successfully!');
            endCallSection.style.display = 'block'; // Show end call button
          } else if (pc.connectionState === 'failed') {
            showStatus('Connection failed. Please try again.', true);
            endCallSection.style.display = 'none'; // Hide end call button
          } else if (pc.connectionState === 'connecting') {
            showStatus('Connecting to other person...');
            endCallSection.style.display = 'none'; // Hide end call button while connecting
          } else if (pc.connectionState === 'disconnected') {
            showStatus('Call disconnected', true);
            endCallSection.style.display = 'none'; // Hide end call button
          }
        };

        pc.oniceconnectionstatechange = () => {
          console.log('ICE connection state:', pc.iceConnectionState);
          if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
            showStatus('Successfully connected to other person!');
            endCallSection.style.display = 'block'; // Show end call button
          } else if (pc.iceConnectionState === 'failed') {
            showStatus('Connection failed. Please check your internet and try again.', true);
            endCallSection.style.display = 'none'; // Hide end call button
          } else if (pc.iceConnectionState === 'checking') {
            showStatus('Checking connection...');
            endCallSection.style.display = 'none'; // Hide end call button while checking
          } else if (pc.iceConnectionState === 'disconnected') {
            showStatus('Connection lost. Trying to reconnect...', true);
            endCallSection.style.display = 'none'; // Hide end call button
          }
        };

        const callRef = ref(db, "calls/" + callId);

        pc.onicecandidate = event => {
          if (event.candidate) {
            console.log('Sending ICE candidate:', event.candidate.candidate);
            const candidateKey = Date.now() + '_' + Math.random().toString(36).substring(2, 9);
            set(ref(db, `calls/${callId}/candidates/${candidateKey}`), event.candidate.toJSON());
          } else {
            console.log('ICE gathering completed');
          }
        };

        // Set up signaling listeners
        onChildAdded(ref(db, `calls/${callId}/signals`), async snapshot => {
          const data = snapshot.val();

          // Handle end call signal
          if (snapshot.key === 'endCall' && data.type === 'endCall') {
            console.log('Received end call signal from other participant');
            showCallEndedModal();
            // End the call locally without sending another signal to avoid loop
            endCallLocally();
            return;
          }

          // Handle WebRTC signaling
          if (!data || !data.sdp) return;

          try {
            console.log('Received signal:', snapshot.key, data.sdp.type);

            if (data.sdp.type === "offer" && !isCaller) {
              // Joiner receives offer
              console.log('Joiner: Setting remote description (offer)');
              await pc.setRemoteDescription(data.sdp);
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              await set(ref(db, `calls/${callId}/signals/answer`), { sdp: pc.localDescription.toJSON() });
              console.log('Joiner: Answer sent');
              showStatus('Answer sent, waiting for connection...');
            } else if (data.sdp.type === "answer" && isCaller) {
              // Creator receives answer
              console.log('Creator: Setting remote description (answer)');
              await pc.setRemoteDescription(data.sdp);
              console.log('Creator: Answer processed');
              showStatus('Answer received, establishing connection...');
            }
          } catch (error) {
            console.error('Error handling signal:', error);
          }
        });

        // For joiners, check if there's already an offer waiting
        if (!isCaller) {
          setTimeout(async () => {
            try {
              const offerSnapshot = await get(ref(db, `calls/${callId}/signals/offer`));
              if (offerSnapshot.exists()) {
                const offerData = offerSnapshot.val();
                console.log('Joiner: Found existing offer');
                await pc.setRemoteDescription(offerData.sdp);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await set(ref(db, `calls/${callId}/signals/answer`), { sdp: pc.localDescription.toJSON() });
                console.log('Joiner: Answer sent to existing offer');
                showStatus('Connected to existing call...');
              }
            } catch (error) {
              console.error('Error checking for existing offer:', error);
            }
          }, 1000);
        }

        onChildAdded(ref(db, `calls/${callId}/candidates`), async snapshot => {
          const cand = snapshot.val();
          if (!cand) return;
          try {
            // Wait for remote description before adding candidates
            if (pc.remoteDescription) {
              await pc.addIceCandidate(cand);
              console.log('Added ICE candidate:', cand.candidate);
            } else {
              console.log('Waiting for remote description before adding candidate');
              // Store candidate to add later
              setTimeout(async () => {
                if (pc.remoteDescription) {
                  await pc.addIceCandidate(cand);
                  console.log('Added delayed ICE candidate:', cand.candidate);
                }
              }, 1000);
            }
          } catch (e) {
            console.warn('Failed to add ICE candidate:', e);
          }
        });

        if (isCaller) {
          // Small delay to ensure all listeners are set up
          setTimeout(async () => {
            try {
              console.log('Creator: Creating and sending offer...');
              const offer = await pc.createOffer();
              await pc.setLocalDescription(offer);
              await set(ref(db, `calls/${callId}/signals/offer`), { sdp: pc.localDescription.toJSON() });
              console.log('Creator: Offer created and sent to Firebase');
              showStatus('Waiting for other person to join...');
            } catch (error) {
              console.error('Error creating offer:', error);
              showStatus('Error creating call. Please try again.', true);
            }
          }, 500);
        } else {
          console.log('Joiner: Waiting for offer...');
          showStatus('Connecting to call...');
        }
      } catch (error) {
        console.error('Error creating peer connection:', error);
        alert('Error setting up connection. Please try again.');
      }
    }

    // Button event handlers
    createBtn.onclick = async () => {
      try {
        // Show permission help first
        document.getElementById('permissionHelp').style.display = 'block';

        showStatus("Click 'Allow' when prompted for camera/microphone access...");
        await initMedia();

        // CRITICAL: Ensure local video is visible IMMEDIATELY for creator
        console.log('Creator: Setting local video immediately after initMedia');
        localVideo.srcObject = localStream;
        await localVideo.play();
        console.log('Creator: Local video should be visible now');

        // Debug check
        setTimeout(() => checkVideoStatus(), 1000);

        currentCallId = generateCallId();
        generatedCallId.value = currentCallId;
        callIdSection.style.display = 'block';

        showStatus("Creating call...");
        await createPeerConnection(currentCallId, true);

        showStatus(`Call created! Share the Call ID: ${currentCallId}`);
        console.log('Call created with ID:', currentCallId);

        // Hide permission help once successful
        document.getElementById('permissionHelp').style.display = 'none';
      } catch (error) {
        console.error('Error creating call:', error);
        showStatus("Error creating call. Please allow camera/microphone access and try again.", true);
      }
    };

    joinBtn.onclick = async () => {
      try {
        const callId = callIdInput.value.trim().toUpperCase();
        if (!callId) {
          showStatus("Please enter a Call ID", true);
          return;
        }

        // Show permission help first
        document.getElementById('permissionHelp').style.display = 'block';

        showStatus("Click 'Allow' when prompted for camera/microphone access...");
        await initMedia();

        // CRITICAL: Ensure local video is visible IMMEDIATELY for joiner
        console.log('Joiner: Setting local video immediately after initMedia');
        localVideo.srcObject = localStream;
        await localVideo.play();
        console.log('Joiner: Local video should be visible now');

        // Debug check
        setTimeout(() => checkVideoStatus(), 1000);

        showStatus("Joining call...");
        currentCallId = callId;
        await createPeerConnection(callId, false);

        showStatus(`Joined call: ${callId}`);
        console.log('Joined call with ID:', callId);

        // Hide permission help once successful
        document.getElementById('permissionHelp').style.display = 'none';
      } catch (error) {
        console.error('Error joining call:', error);
        showStatus('Error joining call. Please allow camera/microphone access and try again.', true);
      }
    };

    // Copy Call ID functionality
    copyCallIdBtn.onclick = async () => {
      try {
        await navigator.clipboard.writeText(currentCallId);
        showStatus("Call ID copied to clipboard!");
        setTimeout(hideStatus, 2000);
      } catch (error) {
        console.error('Error copying to clipboard:', error);
        // Fallback: select the text
        generatedCallId.select();
        generatedCallId.setSelectionRange(0, 99999);
        showStatus("Call ID selected. Press Ctrl+C to copy.");
      }
    };

    // End Call functionality
    endCallBtn.onclick = () => {
      if (confirm('Are you sure you want to end the call?')) {
        endCall();
      }
    };

    // Toggle Video functionality
    toggleVideoBtn.onclick = () => {
      toggleVideo();
    };

    // Request Permissions functionality
    document.getElementById('requestPermissionsBtn').onclick = () => {
      requestPermissionsManually();
    };
  </script>
</body>

</html>
<!-- added -->